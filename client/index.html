<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <title>黑白联棋</title>
    <style>
        body {
            font-family: Arial;
            display: flex;
            flex-direction: column;
            align-items: center;
            background: url('https://ts1.tc.mm.bing.net/th/id/R-C.e79c846015f6778e1fa8cb8b85e3ca2e?rik=KlDMDba0k3BFzw&riu=http%3a%2f%2fimg.hnol.net%2fbbsimg%2f2006-11-24%2f11%2f2006112411592211117.gif&ehk=ycriJJSwfN2Lr04exdNofwFu%2bs9xcfiXSfloNh2BCJY%3d&risl=&pid=ImgRaw&r=0') no-repeat center center fixed;
            background-size: cover;
            padding: 20px;
        }

        h1 {
            color: #ffffff;
            margin-bottom: 20px;
        }

        .game-container {
            display: flex;
            gap: 20px;
        }

        .board {
            display: grid;
            grid-template-columns: repeat(9, 50px);
            grid-template-rows: repeat(9, 50px);
            background: rgba(220, 179, 92, 0.75);
            border: 2px solid #8b4513;
            box-shadow: 0 0 10px rgba(0, 0, 0, .3);
        }

        .cell {
            width: 50px;
            height: 50px;
            border: 1px solid #8b4513;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            position: relative;
        }

        .cell.go-corner {
            cursor: not-allowed;
        }

        .stone {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            position: absolute;
        }

        .stone.black {
            background: #000;
        }

        .stone.white {
            background: #fff;
        }

        .stone.marker::after {
            content: "";
            position: absolute;
            width: 12px;
            height: 12px;
            background: #ff3b30;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 2;
        }

        .info-panel {
            background: linear-gradient(135deg,
                    rgba(255, 255, 255, 0.75) 0%,
                    rgba(253, 253, 253, 0.75) 100%);
            border: 1px solid rgba(224, 224, 224, 0.75);
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            padding: 24px;
            width: 330px;
            font-family: "Segoe UI", "PingFang SC", "Microsoft YaHei", sans-serif;
            color: #333;
        }


        .score {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 20px;
            font-weight: 600;
            padding: 10px 14px;
            background: #f7f7f7;
            border-radius: 10px;
        }

        .score span {
            color: #d9534f;
        }

        .turn {
            text-align: center;
            margin-bottom: 5px;
            font-weight: bold;
            font-size: 18px;
        }

        .mode {
            font-weight: bold;
            color: #d9534f;
            margin-bottom: 10px;
        }

        #move-count {
            font-weight: 700;
            font-size: 18px;
            color: #0275d8;
            margin-bottom: 5px;
        }

        button {
            background: #5cb85c;
            color: #fff;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 3px;
            width: 100%;
            font-size: 16px;
        }

        button:hover {
            background: #ae9a4c;
        }

        .corner {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #8b4513;
            border-radius: 50%;
        }

        .corner.top-left {
            top: -5px;
            left: -5px;
        }

        .corner.top-right {
            top: -5px;
            right: -5px;
        }

        .corner.bottom-left {
            bottom: -5px;
            left: -5px;
        }

        .corner.bottom-right {
            bottom: -5px;
            right: -5px;
        }

        .rules {
            margin-top: 18px;
            font-size: 14px;
            line-height: 1.6;
            color: #555;
        }

        .rules strong {
            font-size: 15px;
            color: #333;
        }

        .rules ol {
            margin: 6px 0 0 20px;
            padding-left: 0;
        }

        .rules li {
            margin-bottom: 4px;
        }
    </style>
</head>

<body>
    <h1>黑白联棋</h1>
    <div class="game-container">
        <div class="board-container">
            <div class="board" id="board"></div>
            <div class="corner top-left"></div>
            <div class="corner top-right"></div>
            <div class="corner bottom-left"></div>
            <div class="corner bottom-right"></div>
        </div>

        <div class="info-panel">
            <div class="score">
                <div>黑方分数:&nbsp;<span id="black-score">0</span></div>
                <div>白方分数:&nbsp;<span id="white-score">0</span></div>
            </div>
            <div class="mode" id="mode">围棋模式</div>
            <div class="turn" id="turn">黑方落子</div>
            <div><strong>当前手数:&nbsp;</strong><span id="move-count">0</span></div>
            <button id="pass-btn" style="display:none">过一手</button>

            <div style="display:flex;gap:10px;margin-top:5px;">
                <button id="undo-btn" style="flex:1">悔棋</button>
                <button id="reset-btn" style="flex:1">重置</button>
            </div>
            <div class="rules">
                <p><strong style="font-size:1.2em;">规则：</strong></p>
                <ol><strong style="font-size:1.0em;">
                        <li>棋盘大小 9×9，双方初始分数均为 0。</li>
                        <li>第一阶段按<span style="color:blue;">围棋</span>规则<span
                                style="color:blue;">(黑先)</span>，四个角不能落子。从中心向四周(5路到1路)，<span style="color:blue;">每吃 1
                                子分别加 1、3、5、7、9 分</span>。40
                            手后可过手，双方连续过手或超过 60 手，进入第二阶段。</li>
                        <li>第二阶段按<span style="color:blue;">黑白棋</span>规则<span style="color:blue;">(黑先)</span>，结束后<span
                                style="color:blue;">每存在 1 个己方棋子加 1 分</span>。
                        </li>
                        <li>两阶段后分数高的一方获胜，分数相同平局。</li>
                    </strong>
                </ol>
            </div>
        </div>
    </div>


    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

    <script>
        /* ===== 给 9×9 棋盘加坐标刻度 ===== */
        const board = document.getElementById('board');
        const size = 9;

        /* 上边横坐标 1-9 */
        const topRuler = document.createElement('div');
        topRuler.style.display = 'grid';
        topRuler.style.gridTemplateColumns = `repeat(${size}, 50px)`;
        topRuler.style.marginLeft = '15px';          /* 与棋盘对齐 */
        topRuler.style.marginBottom = '5px';
        for (let x = 1; x <= size; x++) {
            const label = document.createElement('div');
            label.textContent = x;
            label.style.textAlign = 'center';
            label.style.fontWeight = 'bold';
            label.style.color = '#fff';
            topRuler.appendChild(label);
        }
        board.parentElement.insertBefore(topRuler, board);

        /* 左边纵坐标 1-9 */
        const wrap = document.createElement('div');
        wrap.style.display = 'flex';
        wrap.style.alignItems = 'flex-start';

        const leftRuler = document.createElement('div');
        leftRuler.style.display = 'grid';
        leftRuler.style.gridTemplateRows = `repeat(${size}, 50px)`;
        leftRuler.style.marginTop = '3px';
        leftRuler.style.marginRight = '5px';
        for (let y = 1; y <= size; y++) {
            const label = document.createElement('div');
            label.textContent = y;
            label.style.display = 'flex';
            label.style.alignItems = 'center';
            label.style.justifyContent = 'center';
            label.style.fontWeight = 'bold';
            label.style.color = '#fff';
            leftRuler.appendChild(label);
        }

        /* 重新包一层，让棋盘和左侧刻度并排 */
        board.parentElement.insertBefore(wrap, board);
        wrap.appendChild(leftRuler);
        wrap.appendChild(board);
    </script>

    <script>
        (() => {
            const socket = io('https://1c31f807bdb1.ngrok-free.app');
            const roomId = new URLSearchParams(location.search).get('room') || 'public';
            let mySide = null;

            const SIZE = 9, CORNERS = [[0, 0], [0, 8], [8, 0], [8, 8]];
            let state = {
                board: Array(SIZE).fill().map(() => Array(SIZE).fill(null)),
                turn: 'black', move: 0, black: 0, white: 0, over: false,
                passCount: 0, stage: 'go', koPoint: null, lastMove: null
            };
            let historyStack = [];

            const $ = id => document.getElementById(id);
            const isCorner = (x, y) => CORNERS.some(c => c[0] === x && c[1] === y);
            const nei = [[-1, 0], [1, 0], [0, -1], [0, 1]];
            const copy = b => b.map(r => [...r]);

            // 根据坐标返回吃子得分
            function getCaptureScore(x, y) {
                // 距离最近边线的格数（0 表示 1 路）
                const d = Math.min(x, y, SIZE - 1 - x, SIZE - 1 - y);
                const scoreMap = [9, 7, 5, 3, 1]; // 0->1路 1->2路 ...
                return scoreMap[d] || 0;
            }
            function grp(b, x, y, c) {
                const v = Array(SIZE).fill().map(() => Array(SIZE).fill(false));
                const q = [[x, y]], g = [];
                while (q.length) {
                    const [cx, cy] = q.pop();
                    if (cx < 0 || cx >= SIZE || cy < 0 || cy >= SIZE || v[cy][cx] || b[cy][cx] !== c) continue;
                    v[cy][cx] = true; g.push([cx, cy]);
                    nei.forEach(([dx, dy]) => q.push([cx + dx, cy + dy]));
                }
                return g;
            }
            function lib(b, g) {
                return g.some(([x, y]) => nei.some(([dx, dy]) => {
                    const nx = x + dx, ny = y + dy;
                    return nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE && b[ny][nx] === null;
                }));
            }
            function goMove(x, y) {
                if (state.board[y][x] !== null) return false;
                if (state.koPoint && state.koPoint[0] === x && state.koPoint[1] === y) return false;

                const nb = copy(state.board);
                nb[y][x] = state.turn;

                const opp = state.turn === 'black' ? 'white' : 'black';
                const capturedSet = new Set();
                nei.forEach(([dx, dy]) => {
                    const nx = x + dx, ny = y + dy;
                    if (nx < 0 || nx >= SIZE || ny < 0 || ny >= SIZE || nb[ny][nx] !== opp) return;
                    const g = grp(nb, nx, ny, opp);
                    if (!lib(nb, g)) g.forEach(([cx, cy]) => capturedSet.add(`${cx},${cy}`));
                });
                const caps = [...capturedSet].map(s => s.split(',').map(Number));
                caps.forEach(([cx, cy]) => nb[cy][cx] = null);

                const self = grp(nb, x, y, state.turn);
                if (!lib(nb, self) && caps.length === 0) return false;

                const koCandidate = (caps.length === 1 && self.length === 1) ? caps[0] : null;

                state.board = nb;
                let captureScore = 0;
                caps.forEach(([cx, cy]) => {
                    captureScore += getCaptureScore(cx, cy);
                });
                if (state.turn === 'black') state.black += captureScore;
                else state.white += captureScore;
                state.koPoint = koCandidate;
                return true;
            }

            function othFlip(x, y) {
                if (state.board[y][x] !== null) return [];
                const dirs = [...nei, [-1, -1], [-1, 1], [1, -1], [1, 1]];
                let flip = [];
                dirs.forEach(([dx, dy]) => {
                    let nx = x + dx, ny = y + dy, temp = [];
                    while (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE && state.board[ny][nx] === (state.turn === 'black' ? 'white' : 'black')) {
                        temp.push([nx, ny]); nx += dx; ny += dy;
                    }
                    if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE && state.board[ny][nx] === state.turn && temp.length)
                        flip = flip.concat(temp);
                });
                return flip;
            }
            function othMove(x, y) {
                const f = othFlip(x, y);
                if (f.length === 0) return false;
                state.board[y][x] = state.turn;
                f.forEach(([fx, fy]) => state.board[fy][fx] = state.turn);
                return true;
            }
            function hasLegalMove(color) {
                const tmp = state.turn; state.turn = color;
                for (let y = 0; y < SIZE; y++)
                    for (let x = 0; x < SIZE; x++)
                        if (state.board[y][x] === null && othFlip(x, y).length) {
                            state.turn = tmp; return true;
                        }
                state.turn = tmp; return false;
            }

            function draw() {
                document.querySelectorAll('.cell').forEach(cell => {
                    const x = +cell.dataset.x, y = +cell.dataset.y;
                    cell.innerHTML = '';
                    if (state.board[y][x]) {
                        const s = document.createElement('div');
                        s.className = `stone ${state.board[y][x]}`;
                        if (state.lastMove && state.lastMove[0] === x && state.lastMove[1] === y) s.classList.add('marker');
                        cell.appendChild(s);
                    }
                    const disable = state.stage === 'go' && isCorner(x, y);
                    cell.classList.toggle('go-corner', disable);
                });
                $('black-score').textContent = state.black;
                $('white-score').textContent = state.white;
                $('move-count').textContent = state.move;
                if (!state.over) {
                    let mode = '', pass = false;
                    if (state.stage === 'go') {
                        mode = state.move < 40 ? '围棋模式（当前不可过手）' : '围棋模式（可过手)';
                        pass = state.move >= 40;
                    } else { mode = '黑白棋模式'; pass = true; }
                    $('mode').textContent = mode;

                    if (state.stage === 'othello' && !hasLegalMove(state.turn)) {
                        $('turn').textContent = `${state.turn === 'black' ? '黑方' : '白方'}无子可下，自动跳过`;
                        state.turn = state.turn === 'black' ? 'white' : 'black';
                        state.move++;
                        if (!hasLegalMove('black') && !hasLegalMove('white')) { final(); return; }
                        draw(); return;
                    }

                    const canPass = pass && (state.stage === 'go' || !hasLegalMove(state.turn));
                    $('pass-btn').style.display = canPass ? 'block' : 'none';
                    let turnText = `${state.turn === 'black' ? '黑方' : '白方'}落子`;
                    $('turn').textContent = turnText;
                } else {
                    $('turn').textContent = '游戏结束';
                    $('pass-btn').style.display = 'none';
                }
            }
            function init() {
                const b = $('board'); b.innerHTML = '';
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        const c = document.createElement('div');
                        c.className = 'cell'; c.dataset.x = x; c.dataset.y = y;
                        c.addEventListener('click', () => click(x, y));
                        b.appendChild(c);
                    }
                }
                draw();
                socket.emit('joinRoom', { roomId });
                socket.on('joined', ({ side }) => { mySide = side; draw(); });
                socket.on('start', s => { state = s; draw(); });
                socket.on('update', s => { state = s; draw(); });
                socket.on('illegal', () => alert('非法落子'));
                socket.on('peerLeft', () => alert('对手离开'));
            }
            function click(x, y) {
                socket.emit('move', { roomId, x, y });
            }
            function full() {
                for (let y = 0; y < SIZE; y++)for (let x = 0; x < SIZE; x++)if (state.board[y][x] === null) return false;
                return true;
            }
            let finalAlertTimer;
            function final() {
                let b = state.black, w = state.white;
                for (let y = 0; y < SIZE; y++)for (let x = 0; x < SIZE; x++)
                    if (state.board[y][x] === 'black') b++; else if (state.board[y][x] === 'white') w++;
                state.black = b; state.white = w; state.over = true;
                draw();
                clearTimeout(finalAlertTimer);
                finalAlertTimer = setTimeout(() => alert(`游戏结束\n黑方分数:${b}\n白方分数:${w}\n${b > w ? '黑胜' : w > b ? '白胜' : '平局'}`), 100);
            }
            function pass() {
                socket.emit('pass', roomId);
            }
            function restart() {
                socket.emit('reset', roomId);
            }
            function undo() {
                socket.emit('undo', roomId);
            }
            $('pass-btn').addEventListener('click', pass);
            $('undo-btn').addEventListener('click', undo);
            $('reset-btn').addEventListener('click', () => location.reload());

            const AI = { color: null, delay: 200 };
            const originalDraw = draw;
            draw = function () { originalDraw(); if (!state.over && state.turn === AI.color) setTimeout(aiMove, AI.delay); };

            function goAI() {
                const empty = [];
                for (let y = 0; y < SIZE; y++)for (let x = 0; x < SIZE; x++)if (!isCorner(x, y) && state.board[y][x] === null) empty.push([x, y]);
                if (!empty.length) return null;
                let best = null, bestWin = -Infinity;
                for (const [x, y] of empty) {
                    let wins = 0;
                    for (let sim = 0; sim < 100; sim++) {
                        const nb = copy(state.board); nb[y][x] = state.turn;
                        let diff = 0, c = state.turn;
                        for (let i = 0; i < 100; i++) {
                            const empt = [];
                            for (let Y = 0; Y < SIZE; Y++)for (let X = 0; X < SIZE; X++)if (nb[Y][X] === null && !isCorner(X, Y)) empt.push([X, Y]);
                            if (!empt.length) break;
                            const [nx, ny] = empt[Math.floor(Math.random() * empt.length)];
                            nb[ny][nx] = c;
                            const opp = c === 'black' ? 'white' : 'black';
                            nei.forEach(([dx, dy]) => {
                                const Nx = nx + dx, Ny = ny + dy;
                                if (Nx < 0 || Nx >= SIZE || Ny < 0 || Ny >= SIZE || nb[Ny][Nx] !== opp) return;
                                const g = grp(nb, Nx, Ny, opp);
                                if (!lib(nb, g)) { g.forEach(([cx, cy]) => nb[cy][cx] = null); diff += c === 'black' ? g.length : -g.length; }
                            });
                            c = opp;
                        }
                        wins += diff;
                    }
                    if (wins > bestWin) { bestWin = wins; best = [x, y]; }
                }
                return best;
            }
            function othelloAI() {
                return minimax(state.board, 3, -Infinity, Infinity, state.turn === 'black').move;
            }
            function minimax(board, depth, a, b, maxP) {
                const moves = [];
                for (let y = 0; y < SIZE; y++)for (let x = 0; x < SIZE; x++)if (board[y][x] === null) {
                    const fl = othFlipOnBoard(board, x, y, maxP ? 'black' : 'white');
                    if (fl.length) moves.push([x, y, fl]);
                }
                if (depth === 0 || moves.length === 0) return { score: evaluateBoard(board), move: null };
                let bestMove = null;
                if (maxP) {
                    let maxEval = -Infinity;
                    for (const [x, y, fl] of moves) {
                        const nb = copy(board); nb[y][x] = 'black'; fl.forEach(([fx, fy]) => nb[fy][fx] = 'black');
                        const ev = minimax(nb, depth - 1, a, b, false).score;
                        if (ev > maxEval) { maxEval = ev; bestMove = [x, y]; }
                        a = Math.max(a, ev); if (b <= a) break;
                    }
                    return { score: maxEval, move: bestMove };
                } else {
                    let minEval = Infinity;
                    for (const [x, y, fl] of moves) {
                        const nb = copy(board); nb[y][x] = 'white'; fl.forEach(([fx, fy]) => nb[fy][fx] = 'white');
                        const ev = minimax(nb, depth - 1, a, b, true).score;
                        if (ev < minEval) { minEval = ev; bestMove = [x, y]; }
                        b = Math.min(b, ev); if (b <= a) break;
                    }
                    return { score: minEval, move: bestMove };
                }
            }
            function othFlipOnBoard(b, x, y, c) {
                const dirs = [...nei, [-1, -1], [-1, 1], [1, -1], [1, 1]];
                let flip = [];
                dirs.forEach(([dx, dy]) => {
                    let nx = x + dx, ny = y + dy, temp = [];
                    while (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE && b[ny][nx] === (c === 'black' ? 'white' : 'black')) {
                        temp.push([nx, ny]); nx += dx; ny += dy;
                    }
                    if (nx >= 0 && nx < SIZE && ny >= 0 && ny < SIZE && b[ny][nx] === c && temp.length) flip = flip.concat(temp);
                });
                return flip;
            }
            function evaluateBoard(b) {
                const CORNERS = [[0, 0], [0, 8], [8, 0], [8, 8]];
                let score = 0;
                CORNERS.forEach(([x, y]) => {
                    if (b[y][x] === 'black') score += 20; else if (b[y][x] === 'white') score -= 20;
                });
                for (let i = 1; i < SIZE - 1; i++) {
                    [[0, i], [i, 0], [8, i], [i, 8]].forEach(([x, y]) => {
                        if (b[y][x] === 'black') score += 5; else if (b[y][x] === 'white') score -= 5;
                    });
                }
                let blackFlips = 0, whiteFlips = 0, blackMoves = 0, whiteMoves = 0;
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        if (b[y][x] === 'black') blackFlips++; else if (b[y][x] === 'white') whiteFlips++;
                        if (b[y][x] === null) {
                            const bf = othFlipOnBoard(b, x, y, 'black').length;
                            const wf = othFlipOnBoard(b, x, y, 'white').length;
                            if (bf) blackMoves++; if (wf) whiteMoves++;
                        }
                    }
                }
                score += (blackFlips - whiteFlips) + 2 * (blackMoves - whiteMoves);
                return score;
            }

            function aiMove() {
                if (state.over || state.turn !== AI.color) return;
                let move = null;
                if (state.stage === 'go') move = goAI();
                else move = othelloAI();

                setTimeout(() => {
                    if (move) click(...move);
                    else pass();

                    if (!state.over && state.turn === AI.color) setTimeout(aiMove, AI.delay);
                }, AI.delay);
            }

            init();
        })();
    </script>
</body>

</html>